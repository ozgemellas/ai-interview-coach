/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import { useEffect, useRef } from "react";
import { useGLTF } from "@react-three/drei";
import { useFrame } from "@react-three/fiber";
import * as THREE from "three";
import { useLipSync } from "../hooks/useLipSync";

const MODEL_URL = "/694d323f8f9c70cbc94fb3ce.glb";

interface AvatarProps {
    audioUrl: string | null;
    isPlaying: boolean;
    onEnded: () => void;
}

export function Avatar({ audioUrl, isPlaying, onEnded }: AvatarProps) {
    const { scene } = useGLTF(MODEL_URL);
    const { mouthOpen } = useLipSync(audioUrl, isPlaying, onEnded);
    // Store an array of meshes to animate (e.g., Head, Teeth)
    const morphTargetsRef = useRef<{ mesh: THREE.SkinnedMesh, index: number }[]>([]);
    const neckBoneRef = useRef<THREE.Bone | null>(null);

    useEffect(() => {
        console.log("[LipSync] initializing multi-mesh setup...");
        const targets: { mesh: THREE.SkinnedMesh, index: number }[] = [];

        // Traverse the scene to find ALL meshes with mouth morphs AND the neck bone
        scene.traverse((child) => {
            // Find Neck Bone
            if ((child as any).isBone && (child.name.includes("Neck") || child.name.includes("Head"))) {
                // Prefer Neck for natural sway, but Head works too. 
                // Usually "Neck" is the parent of Head.
                if (!neckBoneRef.current || child.name.includes("Neck")) {
                    console.log(`[Animation] Found control bone: ${child.name}`);
                    neckBoneRef.current = child as THREE.Bone;
                }
            }

            if ((child as any).isSkinnedMesh) {
                const mesh = child as THREE.SkinnedMesh;
                if (mesh.morphTargetDictionary) {
                    const potentialTargets = ["viseme_aa", "mouthOpen", "jawOpen", "MouthOpen", "JawOpen", "mouth_open", "A01_Mouth_Open"];

                    for (const target of potentialTargets) {
                        if (mesh.morphTargetDictionary[target] !== undefined) {
                            console.log(`[LipSync] Connecting '${target}' on '${mesh.name}'`);
                            targets.push({
                                mesh: mesh,
                                index: mesh.morphTargetDictionary[target]
                            });
                            // Once we find a target for this mesh, move to the next mesh
                            break;
                        }
                    }
                }
            }
        });

        morphTargetsRef.current = targets;

        if (targets.length === 0) {
            console.warn("[LipSync] ❌ No actionable morph targets found.");
        } else {
            console.log(`[LipSync] ✅ Connected ${targets.length} meshes for animation.`);
        }
    }, [scene]);

    useFrame((state) => {
        // Apply audio value to all registered meshes
        for (const item of morphTargetsRef.current) {
            if (item.mesh.morphTargetInfluences) {
                item.mesh.morphTargetInfluences[item.index] = mouthOpen.current;
            }
        }

        // Idle Head Animation
        if (neckBoneRef.current) {
            const t = state.clock.getElapsedTime();
            // Subtle breathing/sway
            neckBoneRef.current.rotation.x = Math.sin(t * 1) * 0.05 + 0.1; // Slight look up/down + offset
            neckBoneRef.current.rotation.y = Math.sin(t * 0.5) * 0.05;     // Slow side-to-side
        }
    });

    return (
        <group dispose={null} position={[0, -1.5, 0]}>
            {/* Render the entire model scene as-is */}
            <primitive object={scene} />
        </group>
    );
}

useGLTF.preload(MODEL_URL);

export default Avatar;
